{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Courageous Comets \u2604\ufe0f","text":"<p>Thank you for your interest in our project!</p> <p>This is the documentation for the Courageous Comets Discord bot. It was built as part of the Python Discord Summer Code Jam 2024.</p>"},{"location":"#contents","title":"Contents","text":"<p>This documentation is divided into the following sections:</p> <ul> <li>Contributor Guide: How to set up a development environment and contribute to   the project.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is published under the MIT license.</p>"},{"location":"CHANGELOG/","title":"CHANGELOG","text":""},{"location":"CHANGELOG/#v003-2024-07-16","title":"v0.0.3 (2024-07-16)","text":""},{"location":"CHANGELOG/#v002-2024-07-16","title":"v0.0.2 (2024-07-16)","text":""},{"location":"CHANGELOG/#v001-2024-07-15","title":"v0.0.1 (2024-07-15)","text":""},{"location":"contributor-guide/","title":"Contributor Guide","text":"<p>The contributor guide is intended for developers working on this project. It provides instructions on how to set up a new development environment, along with guidelines on version control, documentation, and testing.</p>"},{"location":"contributor-guide/#contents","title":"Contents","text":"<ul> <li>Development Environment: How to set up your development environment.</li> <li>Version Control: How to manage changes using version control.</li> <li>Documentation: How to write good documentation.</li> <li>Testing: How to test the application.</li> </ul>"},{"location":"contributor-guide/development-environment/","title":"Development Environment","text":"<p>Follow the steps below to set up your development environment.</p> <p>Prerequisites</p> <p>You need to have Git installed on your system.</p>"},{"location":"contributor-guide/development-environment/#cloning-the-repository","title":"Cloning the Repository","text":"<p>To clone the repository, run the following command:</p> <pre><code>git clone https://github.com/thijsfranck/courageous-comets.git\n</code></pre> <p>Next, open the project in your preferred IDE or navigate to the project directory using the terminal.</p>"},{"location":"contributor-guide/development-environment/#environment-setup","title":"Environment Setup","text":"<p>You can set up the development environment using either the automated or manual setup process.</p>"},{"location":"contributor-guide/development-environment/#automated-setup","title":"Automated Setup","text":"<p>The project includes a development container to automatically set up your development environment. See the video installation guide below:</p> <p>For more details, refer to the setup guide for your IDE:</p> <ul> <li>Visual Studio Code (recommended)</li> <li>PyCharm</li> </ul> Cloud Development Environment <p>Alternatively, you can use a GitHub Codespace to set up your development environment in the cloud.</p>"},{"location":"contributor-guide/development-environment/#manual-setup","title":"Manual Setup","text":"<p>If you prefer to set up the development environment manually, follow the steps below.</p> <p>Prerequisites</p> <p>Please ensure Python 3.12 and Poetry are installed on your system.</p>"},{"location":"contributor-guide/development-environment/#install-dependencies","title":"Install Dependencies","text":"<p>Start by installing the project dependencies using Poetry:</p> <pre><code>poetry install\n</code></pre> <p>This will create a virtual environment and install the required dependencies.</p>"},{"location":"contributor-guide/development-environment/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Next, install the pre-commit hooks to ensure that your code is formatted and linted before each commit:</p> <pre><code>poetry run pre-commit install\n</code></pre>"},{"location":"contributor-guide/development-environment/#secrets-management","title":"Secrets Management","text":"<p>To use our team's shared Discord bot token, you will need to retrieve it from the <code>.env.lock</code> file in the project root directory. This section will guide you through the process of decrypting the file to access the token.</p> Can I use my own Discord bot token? <p>Yes, you can use your own Discord bot token.</p> <p>First, create a new bot account on the Discord Developer Portal. Generate a token for your bot account and create a <code>.env</code> file in the project root directory. Add the following line to the file:</p> <pre><code>DISCORD_TOKEN=&lt;YOUR DISCORD TOKEN&gt;\n</code></pre> <p>If you choose to use your own token, you can skip the steps below.</p>"},{"location":"contributor-guide/development-environment/#install-tools","title":"Install Tools","text":"<p>First, you will need to install GnuPG and SOPS on your system. Follow the instructions for your operating system below.</p> WindowsmacOSLinuxDevelopment Container <p>Open a PowerShell terminal and run the following commands:</p> <pre><code>winget install -e --id Mozilla.SOPS\nwinget install -e --id GnuPG.GnuPG\n</code></pre> <p>Open a terminal and run the following command:</p> <pre><code>brew install sops gnupg\n</code></pre> <p>Download the SOPS binary for your platform. For instance, if you are on an amd64 architecture:</p> <pre><code>curl -LO https://github.com/getsops/sops/releases/download/v3.9.0/sops-v3.9.0.linux.amd64\n</code></pre> <p>Move the binary into your <code>PATH</code>:</p> <pre><code>mv sops-v3.9.0.linux.amd64 /usr/local/bin/sops\n</code></pre> <p>Make the binary executable:</p> <pre><code>chmod +x /usr/local/bin/sops\n</code></pre> <p>Finally, install GnuPG:</p> <pre><code>sudo apt-get install -y gnupg\n</code></pre> <p>If you are using the development container, the tools are already installed! \ud83c\udf89</p>"},{"location":"contributor-guide/development-environment/#install-keys","title":"Install Keys","text":"<p>Next, you will need to import the required keys. Copy the files with the keys into your workspace and import them using the following commands:</p> <pre><code>gpg --import courageous-comets.pub.asc\ngpg --import courageous-comets.sec.asc\n</code></pre> <p>The keys will be imported into your keyring.</p> <p>Security Warning</p> <p>Do not share the keys with anyone!</p> Where can I find the keys? <p>You can download the keys from our private Discord server.</p>"},{"location":"contributor-guide/development-environment/#decrypt-envlock","title":"Decrypt <code>.env.lock</code>","text":"<p>Once you have installed the required keys, you can decrypt the <code>.env.lock</code> file using the following command:</p> <pre><code>sops -d --input-type dotenv --output-type dotenv .env.lock &gt; .env\n</code></pre> <p>This will create a decrypted <code>.env</code> file at the project root directory. You can now view the contents of the file and access the Discord bot token.</p> <p>Security Warning</p> <p>Do not commit your decrypted <code>.env</code> file to version control or share the token with anyone!</p>"},{"location":"contributor-guide/development-environment/#running-the-documentation-locally","title":"Running the Documentation Locally","text":"<p>To view the documentation locally, you can use the following command:</p> <pre><code>poetry run mkdocs serve\n</code></pre> <p>Open your browser and navigate to <code>http://localhost:8000</code> to view the documentation. The changes you make to the documentation will be automatically reflected in the browser.</p>"},{"location":"contributor-guide/documentation/","title":"Documentation","text":"<p>Good code documentation aids understanding and speeds up the development process. Follow the guidelines below to document your code effectively.</p>"},{"location":"contributor-guide/documentation/#what-to-document","title":"What to Document","text":"<p>Always document the following elements of your code:</p> <ol> <li>Classes, including their attributes and public methods</li> <li>Module-level functions and constants</li> </ol> <p>Prioritize documenting public methods and attributes (those not starting with an underscore). However, private methods with complex logic should also be documented for clarity.</p>"},{"location":"contributor-guide/documentation/#docstring-format","title":"Docstring Format","text":"<p>This project uses numpy-style docstrings. Refer to the style guide for the full specification and detailed examples.</p> <p>Here are some examples of how to write good documentation for functions and classes:</p> Function Documentation <pre><code>def example_function(param1: int, param2: str):\n    \"\"\"\n    One-line summary of the function.\n\n    Detailed functional description of what the function does. Can span\n    multiple lines.\n\n    Parameters\n    ----------\n    param1 : int\n        Description of the first parameter.\n    param2 : str\n        Description of the second parameter.\n\n    Returns\n    -------\n    bool\n        Description of the return value.\n\n    Raises\n    ------\n    ValueError\n        Description of the error.\n\n    Examples\n    --------\n    &gt;&gt;&gt; example_function(1, \"test\")\n    True\n    \"\"\"\n    ...\n</code></pre> Class Documentation <pre><code>class Example:\n    \"\"\"\n    Class-level docstring describing the class.\n\n    Attributes\n    ----------\n    attribute : int\n        Description of the attribute.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"contributor-guide/documentation/#type-annotations","title":"Type Annotations","text":"<p>Python type annotations are strongly encouraged to improve code readability and maintainability. Use type annotations for all parameters and return values, as well as class attributes.</p> What are type annotations? <p>Type annotations are a way to specify the expected types of variables, function parameters, and return values in Python code. They are used to improve code readability and catch type-related errors early. Refer to the official documentation for more information.</p>"},{"location":"contributor-guide/testing/","title":"Testing","text":"<p>Automated tests are key to our success, since they allow us to catch bugs early, run sections of code in isolation, and accelerate our development pace.</p>"},{"location":"contributor-guide/testing/#structure","title":"Structure","text":"<p>Test modules should be located in the same directory as the module they cover. Test modules should be named <code>test__*.py</code> (e.g.,<code>test__example.py</code>). Individual test methods within those modules should be prefixed with <code>test__</code> (e.g., <code>test__my_function</code>).</p> Test Module Structure <pre><code>project_root/\n\u251c\u2500\u2500 courageous_comets/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 example.py\n\u2502   \u2514\u2500\u2500 test__example.py\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"contributor-guide/testing/#running-tests","title":"Running Tests","text":"<p>We use the <code>pytest</code> framework for writing and running our tests. To run the tests, use the following command from the root of the project:</p> <pre><code>poetry run pytest\n</code></pre> <p>This command will discover and run all the tests modules that match the pattern <code>test__*.py</code>.</p> Running Tests in your IDE <p>Most modern IDEs have built-in support for running tests. You can run tests directly from your IDE, which can be more convenient than running them from the command line.</p> <ul> <li>Visual Studio Code</li> <li>PyCharm</li> </ul> <p>The development container is pre-configured for using <code>pytest</code> in Visual Studio Code.</p>"},{"location":"contributor-guide/testing/#what-to-test","title":"What to Test","text":"<p>Unit tests should cover the following aspects of your code:</p> <ul> <li>Input validation</li> <li>Correctness of output (or outcome) given a valid input</li> <li>Error handling</li> </ul> Consider Edge Cases <p>When writing tests, consider edge cases such as invalid inputs and unexpected behavior. These are often the areas where bugs are most likely to occur.</p> <p>Some parts of the code may be more critical than others. Focus on writing tests for the most critical parts of the codebase, such as complex algorithms, core functionality or user-facing features.</p>"},{"location":"contributor-guide/testing/#writing-tests","title":"Writing Tests","text":"<p>Each test case should be self-contained and independent of other tests. This means that each test should set up its own data and clean up after itself. Avoid relying on the state of other tests or the order in which tests are run.</p> <p>When writing tests, follow these guidelines:</p> <ul> <li>Use descriptive test names that clearly indicate what is being tested.</li> <li>Limit each test to a single logical concept.</li> <li>Use the <code>assert</code> statement to check the expected outcome of the test.</li> <li>Aim for one <code>assert</code> statement per test.</li> <li>Use fixtures to set up common data or resources.</li> </ul> Example Tests <p>The <code>examples</code> folder includes sample tests that you can use as a base for your own test.</p>"},{"location":"contributor-guide/testing/#unit-testing-and-type-annotations","title":"Unit Testing and Type Annotations","text":"<p>You can reduce the need for unit tests by indicating the expected types of input arguments and return values as type annotations. While they don't replace unit tests, type annotations can reduce the number of tests you might need to write, particularly those related to input validation.</p> <p>For instance, consider the following function without type annotations:</p> Function Without Type Annotations <pre><code>def add(a, b):\n    return a + b\n</code></pre> <p>Without type annotations, you might write multiple tests to ensure that the function behaves correctly with different types of input, like strings, integers, or floats. But with type annotations:</p> Function With Type Annotations <pre><code>def add(a: int, b: int) -&gt; int:\n    return a + b\n</code></pre> <p>The function's expected behavior is clearer. You know that both <code>a</code> and <code>b</code> should be integers, and the return value will also be an integer. With these type annotations in place, there's less need to write unit tests checking for behaviors with non-integer inputs since the static type checker can catch those mistakes for you.</p>"},{"location":"contributor-guide/version-control/","title":"Version Control","text":"<p>When making changes to the project, follow these guidelines.</p>"},{"location":"contributor-guide/version-control/#branching","title":"Branching","text":"<p>Always create a new branch for your changes. This makes it easier to handle multiple contributions simultaneously.</p> <p>First, pull the latest changes from the <code>main</code> branch:</p> <pre><code>git pull main\n</code></pre> <p>Next, create a new branch with the following command:</p> <pre><code>git checkout -b \"&lt;YOUR_BRANCH_NAME&gt;\"\n</code></pre> <p>Replace <code>&lt;YOUR_BRANCH_NAME&gt;</code> with a short, descriptive name for your branch. For example, <code>add-uptime-command</code>.</p>"},{"location":"contributor-guide/version-control/#commits","title":"Commits","text":"<p>Commits should follow the Conventional Commits specification. This helps maintain a clean and structured commit history.</p> <p>Try to keep your commits focused on a single task. If you need to make multiple changes, create separate commits for each change.</p> Conventional Commit Format <p>Here's an example of a good commit message:</p> <pre><code>feat: add uptime command\n\nAdd a new command to display the bot's uptime.\n</code></pre> Use Commitizen <p>The workspace includes Commitizen to help you write conventional commit messages. Run the following command to create a commit message interactively:</p> <pre><code>poetry run cz commit\n</code></pre>"},{"location":"contributor-guide/version-control/#automated-checks","title":"Automated Checks","text":"<p>The project includes pre-commit hooks to ensure your code meets the quality standards. These hooks run automatically before each commit.</p> <p>The pre-commit hooks include:</p> <ul> <li>Linting and formatting with Ruff</li> <li>Commit message validation with Commitlint</li> </ul> What if the pre-commit hooks fail? <p>If the pre-commit hooks fail, you will need to address the issues before committing your changes. Follow the instructions provided by the pre-commit hooks to identify and fix the issues.</p> How do I run the pre-commit hooks manually? <p>Pre-commit hooks can also be run manually using the following command:</p> <pre><code>poetry run pre-commit\n</code></pre> <p>The pre-commit hooks are intended to help us keep the codebase maintainable. If there are rules that you believe are too strict, please discuss them with the team.</p>"},{"location":"contributor-guide/version-control/#pull-requests","title":"Pull Requests","text":"<p>Once you have completed your changes, it's time to create a pull request. A pull request allows your changes to be reviewed and merged into the <code>main</code> branch.</p> <p>Before creating a pull request, ensure your branch is up to date with the latest changes from the <code>main</code> branch:</p> <pre><code>git pull main\n</code></pre> <p>Next, push your changes to the repository:</p> <pre><code>git push\n</code></pre> <p>Finally, create a pull request on GitHub. Select your branch as the source and the <code>main</code> branch as the base.</p> <p>In the pull request description, provide a brief overview of the changes and any relevant information for reviewers.</p> Pull Request Description <p>Here's an example of a good pull request description:</p> <pre><code># feat: add uptime command\n\nThis pull request adds a new uptime command to display the bot's uptime.\n\n## Changes\n\n- Added a new command to display the bot's uptime\n- Updated the help command to include information about the new command\n\n## Notes\n\n- The new command is implemented in a separate file for better organization\n- The command has been tested locally and works as expected\n</code></pre>"},{"location":"contributor-guide/version-control/#automated-checks_1","title":"Automated Checks","text":"<p>The project includes automated checks to ensure the code meets the quality standards. These checks include:</p> <ul> <li>All pre-commit hooks must pass</li> <li>Type checking with Pyright</li> <li>Unit tests with pytest</li> </ul> What if the automated checks fail? <p>If any of the automated checks fail, please address the issues before requesting a review. Feedback from the automated checks should be available in the pull request checks tab.</p>"},{"location":"contributor-guide/version-control/#code-review","title":"Code Review","text":"<p>All pull requests should be reviewed by at least one other team member before merging. The reviewer will provide feedback and suggestions for improvement.</p> <p>Once the reviewer approves the pull request, you can merge it into the <code>main</code> branch.</p> How do I request a review? <p>Request a review from a team member by assigning them as a reviewer to your pull request.</p>"},{"location":"contributor-guide/version-control/#giving-feedback","title":"Giving Feedback","text":"<p>When providing feedback on a pull request, be constructive and specific. Point out areas for improvement and suggest possible solutions. If you have any questions or concerns, don't hesitate to ask the author for clarification.</p> <p>A code review should focus on the following aspects:</p> <ul> <li>Correctness and functionality</li> <li>Code quality and readability</li> <li>Adherence to the project guidelines</li> </ul> Good Code Review Feedback <p>Here are some examples of good code review feedback:</p> <pre><code>- Great work on the new command! The implementation looks good overall.\n- I noticed a small typo in the docstring. Could you update it to fix the typo?\n- The logic in the new command is a bit complex. Consider breaking it down into smaller functions for clarity.\n- The tests cover most of the functionality, but we are missing a test case for edge case X. Could you add a test for that?\n</code></pre> <p>Always be respectful and considerate when giving feedback. Remember that the goal is to improve the code and help the author grow as a developer.</p> <p>Be Positive</p> <p>Don't forget to acknowledge the positive aspects of the contribution as well!</p>"},{"location":"contributor-guide/version-control/#release","title":"Release","text":"<p>Releases are managed through Commitizen. To generate a new release, run the following command:</p> <pre><code>poetry run cz bump\n</code></pre> <p>This command will automatically determine the next version number based on the commit history and generate a new tag. It will also update the changelog with the latest changes. To push the changes to the repository, run:</p> <pre><code>git push &amp;&amp; git push --tags\n</code></pre> <p>The release will trigger a GitHub actions workflow to build and publish a new version of the Docker image and update the documentation.</p> Dry Run <p>You can perform a dry run to see the changes that will be made without actually committing them:</p> <pre><code>poetry run cz bump --dry-run\n</code></pre> Commitizen and Conventional Commits <p>Commitizen uses the commit messages to determine the type of changes and generate the release notes. Make sure to follow the commit message guidelines to ensure accurate release notes.</p>"},{"location":"contributor-guide/version-control/#semantic-versioning","title":"Semantic Versioning","text":"<p>Tags should be unique and follow the Semantic Versioning format. Semantic version numbers consist of three parts: <code>major.minor.patch</code>. For example, <code>1.0.0</code>.</p> <p>To calculate the next version number, follow these guidelines:</p> <ul> <li>For bug fixes or minor improvements, increment the patch version.</li> <li>For new features or significant improvements, increment the minor version.</li> <li>For breaking changes, increment the major version.</li> </ul> What is a breaking change? <p>A breaking change requires users to change the way they use the software. Examples include removal of features or backwards-incompatible API changes.</p> Semantic Versioning <p>Here are some examples of version increments:</p> <ul> <li>Bug fixes: <code>1.0.0</code> -&gt; <code>1.0.1</code></li> <li>New features: <code>1.0.1</code> -&gt; <code>1.1.0</code></li> <li>Breaking changes: <code>1.1.0</code> -&gt; <code>2.0.0</code></li> </ul>"},{"location":"contributor-guide/version-control/#github-actions","title":"GitHub Actions","text":"<p>A GitHub actions workflow will automatically build and publish a new version of the Docker image when a new tag is pushed to the repository.</p> <p>The updated image will be available on the GitHub Container Registry with both the release tag and the <code>latest</code> tag.</p> <p>The GitHub actions workflow also updates the documentation to reflect the new release.</p>"}]}